#include "LedControl.h"
#include "TimerOne.h"
#include <LiquidCrystal.h>


int state = HIGH;      // the current state of the output pin
int reading;           // the current reading from the input pin <-- PLAY STOP BUTTON KRAM
int previous = LOW;    // the previous reading from the input pin
int PlayStopButton = 5; // 
long interruptinterval = 500000;
float bpm =0;
int Patternlenght = 7;

// the follow variables are long's because the time, measured in miliseconds,
// will quickly become a bigger number than can be stored in an int.
long time = 0;  
long time2 = 0; // the last time the output pin was toggled
long debounce2 = 200;
long debounce = 200;   // the debounce time, increase if the output flickers
bool kick[8]       ={1,0,1,0,1,0,1,0};
bool snare[8]      ={0,0,1,0,0,0,1,0};
bool hat[8]        ={1,1,1,1,1,1,1,1};
bool bongoinnen[8] ={0,0,0,1,0,0,0,1};
bool bongoaussen[8]={0,0,0,0,0,0,0,0};
bool extra1[8]     ={0,0,0,0,0,0,0,0};
bool extra2[8]     ={0,0,0,0,0,0,0,0};
bool extra3[8]     ={0,0,0,0,0,0,0,0};
int buttonpinshori[8]  ={A8,A9,A10,A11,A12,A13,A14,A15};
int buttonpinsvert[5]  ={48,49,50,51,52};
int lastbuttonstatehori[8]={0,0,0,0,0,0,0,0};
int lastbuttonstatevert[5]={0,0,0,0,0};
 
int Taktzaehler = 0;

const int rs = A4, en = A5, d4 = A0, d5 = A1, d6 = A2, d7 = A3;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);
/*const int buttonpin1 = 40;
const int buttonpin2 = 41;
const int buttonpin3 = 42;
const int buttonpin4 = 43;
const int buttonpin5 = 44;
const int buttonpin6 = 45;
const int buttonpin7 = 46;
const int buttonpin8 = 47;
const int buttonpin9 = 48;
const int buttonpin10 = 49;
const int buttonpin11 = 50;
const int buttonpin12 = 51;
*/

LedControl lc=LedControl(12,11,10,1);

//Pin connected to latch pin (ST_CP) of 74HC595
const int latchPin = 8;
//Pin connected to clock pin (SH_CP) of 74HC595
const int clockPin = 9;
////Pin connected to Data in (DS) of 74HC595
const int dataPin = 7;

const int numReadings = 10; // POTI PATTERNLÄNGE SMOOTHING

int input = 0;

int readings[numReadings];      // the readings from the analog input
int readIndex = 0;              // the index of the current reading
int total = 0;                  // the running total
int average = 0;                // the average

void setup() {
  DDRC = B00000000; // PORTC = EINGANG
  DDRA = B11111111; // PORTA = AUSGANG
  
  lc.shutdown(0,false); // Initialisierung LED Matrix
  lc.setIntensity(0,8);
  lc.clearDisplay(0);

  // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
  // Print a message to the LCD.

  pinMode(latchPin, OUTPUT); // PINS 74HC595 Schieberegister 7Seg-Anzeige
  pinMode(dataPin, OUTPUT);  
  pinMode(clockPin, OUTPUT);

  Serial1.begin(31250); // Initialisierung Serielle Verbindung MIDI
  Serial.begin(9600);

  Timer1.initialize(interruptinterval); // Initialisierung Interupt (Startintervall 500000 microsec)
  Timer1.attachInterrupt( timerIsr ); // Serviceroutine: "timerIsr"
  
  pinMode(PlayStopButton, INPUT);
  /*pinMode(38, INPUT);
  pinMode(41, INPUT);
  pinMode(42, INPUT);
  pinMode(43, INPUT);
  pinMode(44, INPUT);
  pinMode(45, INPUT);
  pinMode(46, INPUT);
  pinMode(47, INPUT);
  */
  pinMode(48, INPUT);
  pinMode(49, INPUT);
  pinMode(50, INPUT);
  pinMode(51, INPUT);
  pinMode(52, INPUT);
  pinMode(A0, OUTPUT);
  pinMode(A1, OUTPUT);
  pinMode(A2, OUTPUT);
  pinMode(A3, OUTPUT);
  pinMode(A4, OUTPUT);
  pinMode(A5, OUTPUT);
  pinMode(A8, OUTPUT);
  pinMode(A9, OUTPUT);
  pinMode(A10, OUTPUT);
  pinMode(A11, OUTPUT);
  pinMode(A12, OUTPUT);
  pinMode(A13, OUTPUT);
  pinMode(A14, OUTPUT);
  pinMode(A15, OUTPUT);
 
    // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
  // Print a message to the LCD.
  
  for (int thisReading = 0; thisReading < numReadings; thisReading++) { // POTI SMOOTHING
    readings[thisReading] = 0;
  }
}

void loop() {
  checkMatrix();
  checkButtons();
  checkTempo();
  checkPatternlenght();
  displayprog();
  //PORTC = input;
  PORTA = B11111111;
}
void displayprog(){
  // set the cursor to column 0, line 1
  // (note: line 1 is the second row, since counting begins with 0):
  lcd.setCursor(0, 0);
  lcd.print("Patternlaenge: ");
  lcd.print(Patternlenght+1);
  lcd.setCursor(0, 1);
  // print the number of seconds since reset:
  lcd.print("BPM: ");
  lcd.print(bpm);
  lcd.setCursor(8, 1);
  lcd.print(" Step: ");
  lcd.print(Taktzaehler);
  
}
void checkPatternlenght(){
   // subtract the last reading:
  total = total - readings[readIndex];
  // read from the sensor:
  readings[readIndex] = map (analogRead(A7),0,1023,0,8); // = 8, weil Poti/ AnalogRead Fehlerhaft ist
  // add the reading to the total:
  total = total + readings[readIndex];
  // advance to the next position in the array:
  readIndex = readIndex + 1;

  // if we're at the end of the array...
  if (readIndex >= numReadings) {
    // ...wrap around to the beginning:
    readIndex = 0;
  }

  // calculate the average:
Patternlenght = total / numReadings;
  //Patternlenght = map (analogRead(A7),0,1023,0,8); // = 8, weil Poti/ AnalogRead Fehlerhaft ist
  if (Patternlenght != 8){
  for (int x = 0; x<8; x++)
      {
        lc.setLed(0,6,x,false);
      }
  }
  lc.setLed(0,6,Patternlenght,true);
}
void checkTempo() {
  bpm = 60000000/interruptinterval;
  /*Serial.print("BPM: ");
  Serial.println(bpm);
  Serial.print("Patternlänge: ");
  Serial.println(Patternlenght+1);
  */
  if (digitalRead(6))
  {
  //Timer1.detachInterrupt();
  //Timer1.attachInterrupt( timerIsr,map(analogRead(A6),0,1023,100000,10000000)); // attach the service routine here  
  interruptinterval = map(analogRead(A7),0,1023,50000,900000);
  Timer1.setPeriod(interruptinterval);
  while(!digitalRead(6)){}
  }
}
void timerIsr() {
  if (Taktzaehler != -1){
  if (kick[Taktzaehler] == true)
    {
    noteOn(0x90,0x3C,0x7F);
    noteOn(0x90,0x3C,0x00);
    noteOn(0x90,0x1E,0x7F);
    noteOn(0x90,0x1E,0x00);
    do{
      PORTA =B11111111;
    }
    while(digitalRead(36)==HIGH);
    PORTA = B11111011;  
    }
  if (snare[Taktzaehler] == true)
    {
    noteOn(0x90,0x3E,0x7F);
    noteOn(0x90,0x3E,0x00);
    do{
    PORTA =B11111111;
    }
    while(digitalRead(36)==HIGH);
    PORTA = B11110111; 
    }
  if (hat[Taktzaehler] == true)
    {
    noteOn(0x90,0x3F,0x7F);
    noteOn(0x90,0x3F,0x00);
    do{
    PORTA =B11111111;
    }
    while(digitalRead(36)==HIGH);
    PORTA = B11011111;   
    }
  if (bongoinnen[Taktzaehler] == true)
    {
    noteOn(0x90,0x40,0x7F);
    noteOn(0x90,0x40,0x00); 
     do{
    PORTA =B11111111;
    }
    while(digitalRead(36)==HIGH);
    PORTA = B11101111;   
    } 
    
  if (bongoaussen[Taktzaehler] == true)
    {
    noteOn(0x90,0x41,0x7F);
    noteOn(0x90,0x41,0x00); 
    do{
    PORTA =B11111111;
    }
    while(digitalRead(36)==HIGH);
    PORTA = B01111111; 
    } 
  }
 switch (Taktzaehler) {
    case -1: // STOP --- um Interrupt wieder zu starten, bei START-Druck Taktzaehler auf 0 setzen und Timer1.attachen
      for (int x = 0; x<8; x++)
      {
        lc.setLed(0,7,x,false);
      }
      digitalWrite(latchPin, LOW);
      shiftOut(dataPin, clockPin, LSBFIRST, B00000010); // 7seg ="-"
      digitalWrite(latchPin, HIGH);
      break;
    case 0:           // SCHRITT 1 
      Taktzaehler++;
      for (int x = 0; x<8; x++)
      {
        lc.setLed(0,7,x,false);
      }
      lc.setLed(0,7,0,true);
      lc.setLed(0,7,7,false);
      digitalWrite(latchPin, LOW);
      shiftOut(dataPin, clockPin, LSBFIRST, B01100000); // 7seg ="1"
      digitalWrite(latchPin, HIGH);
      if (Taktzaehler-1 == Patternlenght) {Taktzaehler = 0;}
      break;    
    case 1:           // SCHRITT 2 
      Taktzaehler++;
      lc.setLed(0,7,1,true);
      lc.setLed(0,7,0,false);
      digitalWrite(latchPin, LOW);
      shiftOut(dataPin, clockPin, LSBFIRST, B11011010); // 7seg ="2"
      digitalWrite(latchPin, HIGH);
      if (Taktzaehler-1 == Patternlenght) {Taktzaehler = 0;}
      break;
    case 2:           // SCHRITT 3
      Taktzaehler++;
      lc.setLed(0,7,2,true);
      lc.setLed(0,7,1,false);
      digitalWrite(latchPin, LOW);
      shiftOut(dataPin, clockPin, LSBFIRST, B11110010); // 7seg ="3"
      digitalWrite(latchPin, HIGH);
      if (Taktzaehler-1 == Patternlenght) {Taktzaehler = 0;}
      break;
    case 3:           // SCHRITT 4
      Taktzaehler++;
      lc.setLed(0,7,3,true);
      lc.setLed(0,7,2,false);
      digitalWrite(latchPin, LOW);
      shiftOut(dataPin, clockPin, LSBFIRST, B01100110); // 7seg ="4"
      digitalWrite(latchPin, HIGH);
      if (Taktzaehler-1 == Patternlenght) {Taktzaehler = 0;}
      break;
    case 4:           // SCHRITT 5
      Taktzaehler++;
      lc.setLed(0,7,4,true);
      lc.setLed(0,7,3,false);
      digitalWrite(latchPin, LOW);
      shiftOut(dataPin, clockPin, LSBFIRST, B10110110); // 7seg ="5"
      digitalWrite(latchPin, HIGH);
      if (Taktzaehler-1 == Patternlenght) {Taktzaehler = 0;}
      break;
    case 5:           // SCHRITT 6
      Taktzaehler++;
      lc.setLed(0,7,5,true);
      lc.setLed(0,7,4,false);
      digitalWrite(latchPin, LOW);
      shiftOut(dataPin, clockPin, LSBFIRST, B10111110); // 7seg ="6"
      digitalWrite(latchPin, HIGH);
      if (Taktzaehler-1 == Patternlenght) {Taktzaehler = 0;}
      break;
    case 6:           // SCHRITT 7
      Taktzaehler++;
      lc.setLed(0,7,6,true);
      lc.setLed(0,7,5,false);
      digitalWrite(latchPin, LOW);
      shiftOut(dataPin, clockPin, LSBFIRST, B11100000); // 7seg ="7"
      digitalWrite(latchPin, HIGH);
      if (Taktzaehler-1 == Patternlenght) {Taktzaehler = 0;}
      break;
    case 7:           // SCHRITT 8
      Taktzaehler = 0;
      lc.setLed(0,7,7,true);
      lc.setLed(0,7,6,false);
      digitalWrite(latchPin, LOW);
      shiftOut(dataPin, clockPin, LSBFIRST, B11111110); // 7seg ="8"
      digitalWrite(latchPin, HIGH);
      break;
  }
}
void checkButtons()
{
reading = digitalRead(PlayStopButton);
// compare the buttonState to its previous state
  if (reading == HIGH && previous == LOW && millis() - time > debounce) {
    if (state == HIGH){
      state = LOW;
      Taktzaehler = -1;
    }
    else{
      state = HIGH;
      if (Taktzaehler == -1)
      {
        Taktzaehler = 0;
       }
      else {
        Taktzaehler=Taktzaehler;
        }
    }
    time = millis();    
  }


  previous = reading;

  for (int hori = 0; hori < 8; hori ++){
    for (int vert = 0; vert < 5; vert ++){
      if ((digitalRead(buttonpinsvert[vert]) == HIGH && digitalRead(buttonpinshori[hori]) && millis() - time2 > debounce2) == HIGH ){
        
        if (vert == 0){ // KICK
          if (kick[hori] == 0){
            kick[hori] = 1;
          }
          else {kick[hori] =0;}
          time2 = millis();  
        }
        else{};
        if (vert == 1){ // SNARE
          if (snare[hori] == 0){
            snare[hori] = 1;
          }
          else {snare[hori] =0;}
          time2 = millis();   
        }
        if (vert == 2){ // HIGHHAT
          if (hat[hori] == 0){
            hat[hori] = 1;
          }
          else {hat[hori] =0;}
          time2 = millis();   
        }
        else{};
        if (vert == 3){ // BONGOINNEN
          if (bongoinnen[hori] == 0){
            bongoinnen[hori] = 1;
          }
          else {bongoinnen[hori] =0;}
          time2 = millis();   
        }
        else{};

      }
      
      else{};
      
    }
    
  }
 
}
void checkMatrix() 
{
 int i;
 for (i = 0; i < 8; i = i + 1) 
  {
   if (kick[i] == true)
    { 
    lc.setLed(0,0,i,true);
    }
   else
    {
    lc.setLed(0,0,i,false);
    }
   if (snare[i] == true)
    { 
    lc.setLed(0,1,i,true);
    }
   else
    {
    lc.setLed(0,1,i,false);
    }
   if (hat[i] == true)
    { 
    lc.setLed(0,2,i,true);
    }
   else
    {
    lc.setLed(0,2,i,false);
    }
   if (bongoinnen[i] == true)
    { 
    lc.setLed(0,3,i,true);
    }
   else
    {
    lc.setLed(0,3,i,false);
    }
    if (bongoaussen[i] == true)
    { 
    lc.setLed(0,4,i,true);
    }
   else
    {
    lc.setLed(0,4,i,false);
    }
  }
}

void noteOn(int cmd, int pitch, int velocity) {
  Serial1.write(cmd);
  Serial1.write(pitch);
  Serial1.write(velocity);
}
/*int potiWert = 0;
int zaehler = 0;

int bit1 = 0;
int bit2 = 0;
int bit3 = 0;

  for ( zaehler = 0 ; zaehler <= 7; zaehler++ ) {

  bit1 = bitRead(zaehler, 0);
  bit2 = bitRead(zaehler, 1);
  bit3 = bitRead(zaehler, 2);

  digitalWrite(2, bit1);
  digitalWrite(3, bit2);
  digitalWrite(4, bit3);

  potiWert = analogRead(A0);
  */
